**Potential optimization issues**

1. **CPU-heavy adaptive filter chain always enabled** – Every encoding run applies HQDN3D denoising, scaling, debanding, unsharp, and FPS limiting regardless of the user intention or source quality (@Services/VideoCompressionService.cs#590-706, @Services/AdaptiveFilterBuilder.cs#14-92). This adds multiple passes over the entire frame pipeline even when downscaling isn’t requested or when only a light trim is needed. Consider making filters opt-in per strategy or skipping expensive ones (e.g., HQDN3D/deband) when the bitrate budget is high or when the user only needs a simple transcode.

2. **Segment handling duplicates costly work** – [ProcessSegmentsAsync](cci:1://file:///c:/Coding/liteclip/Services/VideoCompressionService.cs:250:4-291:5) either extracts+merges segments up front or defers to [BuildTrimFilters](cci:1://file:///c:/Coding/liteclip/Services/VideoCompressionService.cs:1327:4-1343:5), but when compression is skipped the code synchronously re-runs [MergeVideoSegmentsAsync](cci:1://file:///c:/Coding/liteclip/Services/VideoCompressionService.cs:1596:4-1758:5) via `.GetAwaiter().GetResult()` just to copy the file (@Services/VideoCompressionService.cs#317-349). This blocks the request thread and needlessly re-encodes segments. Avoid synchronous waits (wrap in async) and reuse prior processed artifacts so “skip compression” becomes a simple copy.

3. **Two-pass always preferred even when hardware encoders selected** – Jobs default to two-pass planning and only later disable it if `job.EncoderIsHardware` evaluates true (@Services/VideoCompressionService.cs#709-717). This still builds pass2 artifacts, logs, and plans before discovering hardware is in use. Detect hardware upfront when selecting strategy/encoder so you don’t build/clean pass logs or compute two-pass bitrate plans.

4. **Encoder selection performs redundant probing** – Each job lazily calls [_encoderSelectionService.IsHardwareEncoder](cci:1://file:///c:/Coding/liteclip/Services/EncoderSelectionService.cs:55:4-64:5), which just string-checks per invocation (@Services/VideoCompressionService.cs#650-669). However, the preferred encoder itself is resolved elsewhere (e.g., [GetBestH264Encoder](cci:1://file:///c:/Coding/liteclip/Services/EncoderSelectionService.cs:35:4-38:5)). Cache the encoder + hardware flag once per codec at app startup to avoid repeated probe/regex work per job.

5. **`VideoMetadataService` sequential fallback probes** – For every metadata request, the service runs JSON, CSV, and raw ffprobe invocations sequentially, each reading whole streams even when only duration/size is needed (@Services/VideoMetadataService.cs#64-311). Short-circuit earlier (e.g., request only duration/width once) and use targeted `-show_entries` flags to avoid parsing entire stream manifests multiple times.

6. **Frontend bundle lacks route/component-level code splitting** – `App.svelte` imports every large component eagerly (@frontend/src/App.svelte#4-95), so the Photino WebView loads the entire UI even when many panels (settings modal, video editor) are never opened. Use dynamic `await import()` for heavy modals/panels to reduce initial WebView bootstrap time.

7. **Verbose logging + console statements always shipped** – The frontend still logs detailed status (e.g., video loader `console.log` spam, main.ts mount logs) even though production build drops console statements only via terser (risking partial removal) (@frontend/src/main.ts#10-49, @frontend/src/services/videoLoader.ts#311-350). Prefer gated logging (e.g., `if (import.meta.env.DEV)`) to avoid bundling log strings and keep terser from needing to strip them.

Let me know if you’d like concrete patches (requires Code mode) or profiling guidance for any of the above.