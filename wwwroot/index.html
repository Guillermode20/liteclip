<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Video Compressor</title>
    <style>
        * {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
        }
        body {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #1e1e1e;
            color: #d4d4d4;
        }
        .container {
            background-color: #252526;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.5);
            border: 1px solid #3e3e42;
        }
        h1 {
            color: #569cd6;
            text-align: center;
            margin-bottom: 30px;
        }
        .upload-area {
            border: 2px dashed #3e3e42;
            border-radius: 8px;
            padding: 40px;
            text-align: center;
            margin-bottom: 20px;
            transition: border-color 0.3s;
            background-color: #1e1e1e;
            color: #d4d4d4;
        }
        .upload-area:hover {
            border-color: #569cd6;
        }
        .upload-area.dragover {
            border-color: #569cd6;
            background-color: #2d2d30;
        }
        #fileInput {
            margin-bottom: 10px;
        }
        #uploadBtn {
            background-color: #0e639c;
            color: #ffffff;
            border: none;
            padding: 12px 24px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            margin-top: 10px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
        }
        #uploadBtn:hover {
            background-color: #1177bb;
        }
        #uploadBtn:disabled {
            background-color: #3e3e42;
            color: #858585;
            cursor: not-allowed;
        }
        #status {
            margin-top: 20px;
            padding: 10px;
            border-radius: 4px;
            display: none;
        }
        .status-processing {
            background-color: #4a4a2a;
            color: #dcdcaa;
            border: 1px solid #6a6a3a;
        }
        .status-success {
            background-color: #2d4a2d;
            color: #9cdcfe;
            border: 1px solid #4d6a4d;
        }
        .status-error {
            background-color: #4a2d2d;
            color: #f48771;
            border: 1px solid #6a4d4d;
        }
        #downloadBtn {
            background-color: #0e7c0e;
            color: #ffffff;
            border: none;
            padding: 12px 24px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            margin-top: 10px;
            display: none;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
        }
        #downloadBtn:hover {
            background-color: #117711;
        }
        .progress {
            margin-top: 10px;
            display: none;
        }
        .progress-bar {
            width: 100%;
            height: 20px;
            background-color: #1e1e1e;
            border-radius: 10px;
            overflow: hidden;
            border: 1px solid #3e3e42;
        }
        .progress-fill {
            height: 100%;
            background-color: #569cd6;
            width: 0%;
            transition: width 0.3s;
        }
        .progress-fill.compressing {
            background: linear-gradient(90deg, #569cd6 0%, #0e639c 50%, #569cd6 100%);
            background-size: 200% 100%;
            animation: pulse 2s ease-in-out infinite;
        }
        @keyframes pulse {
            0%, 100% { background-position: 0% 0%; }
            50% { background-position: 100% 0%; }
        }
        .file-info {
            margin-top: 10px;
            font-size: 14px;
            color: #858585;
        }
        .mode-toggle {
            display: flex;
            gap: 16px;
            align-items: center;
            margin-bottom: 12px;
        }
        .mode-toggle label {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 14px;
            color: #d4d4d4;
            cursor: pointer;
        }
        .codec-select {
            margin-bottom: 12px;
        }
        .codec-select select {
            width: 100%;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #3e3e42;
            font-size: 14px;
            background-color: #1e1e1e;
            color: #d4d4d4;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
        }
        .codec-select select option {
            background-color: #252526;
            color: #d4d4d4;
        }
        .helper-text {
            font-size: 12px;
            color: #858585;
        }
        .estimate-line {
            font-size: 12px;
            color: #d4d4d4;
            margin-top: 4px;
        }
        .preset-btn {
            padding: 6px 12px;
            border: 1px solid #569cd6;
            background-color: #252526;
            color: #569cd6;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
        }
        .preset-btn:hover {
            background-color: #569cd6;
            color: #1e1e1e;
        }
        .preset-btn:active {
            transform: scale(0.95);
        }
        input[type="range"] {
            background-color: #1e1e1e;
            -webkit-appearance: none;
            appearance: none;
            height: 8px;
            border-radius: 4px;
            outline: none;
        }
        input[type="range"]::-webkit-slider-runnable-track {
            background: #3e3e42;
            height: 8px;
            border-radius: 4px;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background-color: #569cd6;
            cursor: pointer;
            margin-top: -5px;
        }
        input[type="range"]::-moz-range-track {
            background: #3e3e42;
            height: 8px;
            border-radius: 4px;
        }
        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background-color: #569cd6;
            cursor: pointer;
            border: none;
        }
        #metadata {
            color: #d4d4d4;
        }
        #metadata strong {
            color: #569cd6;
        }
        label strong {
            color: #569cd6;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Video Compressor</h1>

        <div class="upload-area" id="uploadArea">
            <input type="file" id="fileInput" accept="video/*" style="display: none;">
            <p>Drag and drop a video file here, or click to select</p>
            <div class="file-info" id="fileInfo"></div>
        </div>

        <div id="metadata" style="display: none; margin-top: 12px; margin-bottom: 16px; text-align: left; font-size: 14px; color: #d4d4d4;"></div>

        <div class="controls" id="controls" style="margin-bottom: 20px; display: none; text-align: left;">
            <div style="margin-bottom: 16px;">
                <label for="outputSizeSlider"><strong>Target output size</strong>: <span id="outputSizeValue">--</span></label>
                <div style="display: flex; gap: 8px; margin-top: 8px; margin-bottom: 8px; flex-wrap: wrap;">
                    <button type="button" class="preset-btn" data-target-percent="25">75% smaller</button>
                    <button type="button" class="preset-btn" data-target-percent="50">50% smaller</button>
                    <button type="button" class="preset-btn" data-target-percent="75">25% smaller</button>
                </div>
                <input type="range" id="outputSizeSlider" min="1" max="100" step="0.5" value="100" style="width: 100%;">
                <div class="helper-text">Drag left to compress more. Automatically adjusts quality and resolution.</div>
                <div class="estimate-line" id="outputSizeDetails"></div>
            </div>
            <div class="codec-select">
                <label for="codecSelect"><strong>Codec</strong></label>
                <select id="codecSelect">
                    <option value="h264">H.264 (MP4)</option>
                    <option value="h265">H.265 / HEVC (MP4)</option>
                    <option value="vp9">VP9 (WebM)</option>
                    <option value="av1">AV1 (WebM)</option>
                </select>
                <div class="helper-text" id="codecHelper">Best compatibility across browsers and devices.</div>
            </div>
        </div>

        <button id="uploadBtn" disabled style="width: 100%; margin-bottom: 20px;">Upload & Compress Video</button>

        <div class="progress" id="progress">
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
        </div>

        <div id="status"></div>

        <button id="downloadBtn">Download Compressed Video</button>
    </div>

    <script>
        let selectedFile = null;
        let jobId = null;
        let statusCheckInterval = null;
        let downloadFileName = null;
        let downloadMimeType = null;

        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        const uploadBtn = document.getElementById('uploadBtn');
        const fileInfo = document.getElementById('fileInfo');
        const controlsDiv = document.getElementById('controls');
        const metadataDiv = document.getElementById('metadata');
        const statusDiv = document.getElementById('status');
        const downloadBtn = document.getElementById('downloadBtn');
        const progressDiv = document.getElementById('progress');
        const progressFill = document.getElementById('progressFill');
        const codecSelect = document.getElementById('codecSelect');
        const codecHelper = document.getElementById('codecHelper');
        const outputSizeSlider = document.getElementById('outputSizeSlider');
        const outputSizeValue = document.getElementById('outputSizeValue');
        const outputSizeDetails = document.getElementById('outputSizeDetails');

        const codecDetails = {
            h264: {
                helper: 'Best compatibility across browsers and devices.',
                container: 'mp4',
            },
            h265: {
                helper: 'Higher efficiency than H.264 but slower to encode. Limited support on older devices.',
                container: 'mp4',
            },
            vp9: {
                helper: 'Great for modern browsers. Outputs WebM files optimized for streaming.',
                container: 'webm',
            },
            av1: {
                helper: 'Smallest files but slowest encode. Requires very recent hardware/software.',
                container: 'webm',
            },
        };

        // Handle drag and drop
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });

        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFileSelect(files[0]);
            }
        });

        uploadArea.addEventListener('click', (e) => {
            // Avoid triggering file picker when clicking the upload button
            if (e.target === uploadBtn || uploadBtn.contains(e.target)) return;
            fileInput.click();
        });

        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFileSelect(e.target.files[0]);
            }
        });

        let objectUrl = null;
        let sourceVideoWidth = null;
        let sourceVideoHeight = null;
        let sourceDuration = null;
        let originalSizeMb = null;

        function handleFileSelect(file) {
            if (!file.type.startsWith('video/')) {
                alert('Please select a video file');
                return;
            }

            selectedFile = file;
            // Store original size in MB for UI calculations
            originalSizeMb = selectedFile.size / (1024 * 1024);
            fileInfo.textContent = `Selected: ${file.name} (${formatFileSize(file.size)})`;
            uploadBtn.disabled = false;
            uploadBtn.textContent = 'Upload & Compress Video';
            controlsDiv.style.display = 'block';
            metadataDiv.style.display = 'none';

            outputSizeSlider.disabled = true;
            outputSizeValue.textContent = '--';
            outputSizeDetails.textContent = 'Reading video metadata...';
            updateCodecHelper();

            // Load metadata
            if (objectUrl) URL.revokeObjectURL(objectUrl);
            objectUrl = URL.createObjectURL(file);
            const videoEl = document.createElement('video');
            videoEl.preload = 'metadata';
            videoEl.src = objectUrl;
            videoEl.addEventListener('loadedmetadata', () => {
                sourceVideoWidth = videoEl.videoWidth || null;
                sourceVideoHeight = videoEl.videoHeight || null;
                const duration = isFinite(videoEl.duration) ? videoEl.duration : null;
                sourceDuration = duration;
                const kbps = duration ? Math.round((file.size * 8) / duration / 1000) : null;
                const dimsText = (sourceVideoWidth && sourceVideoHeight) ? `${sourceVideoWidth}×${sourceVideoHeight}` : 'Unknown';
                const durationText = duration ? `${duration.toFixed(2)}s` : 'Unknown';
                const bitrateText = kbps ? `${kbps} kbps (approx)` : 'Unknown';
                metadataDiv.innerHTML = `
                    <div><strong>File size</strong>: ${formatFileSize(file.size)}</div>
                    <div><strong>Type</strong>: ${file.type || 'Unknown'}</div>
                    <div><strong>Duration</strong>: ${durationText}</div>
                    <div><strong>Resolution</strong>: ${dimsText}</div>
                    <div><strong>Bitrate</strong>: ${bitrateText}</div>
                `;
                metadataDiv.style.display = 'block';
                
                // Configure slider: starts at 100% (original size), can't go above it
                outputSizeSlider.max = 100;
                outputSizeSlider.value = 100;
                outputSizeSlider.disabled = false;
                updateOutputSizeDisplay();
            }, { once: true });
        }

        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        // Output size slider event handler
        outputSizeSlider.addEventListener('input', () => {
            updateOutputSizeDisplay();
        });
        
        codecSelect.addEventListener('change', () => {
            updateCodecHelper();
            updateOutputSizeDisplay();
        });
        
        // Preset button handlers
        document.querySelectorAll('.preset-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                if (outputSizeSlider.disabled) return;
                
                const targetPercent = btn.getAttribute('data-target-percent');
                const targetSize = btn.getAttribute('data-size');
                
                if (targetPercent && originalSizeMb) {
                    // Set percentage of original (e.g., 50% = half the size)
                    outputSizeSlider.value = targetPercent;
                    updateOutputSizeDisplay();
                } else if (targetSize && originalSizeMb) {
                    // Set specific MB size
                    const sizeMb = parseFloat(targetSize);
                    const percent = Math.min(100, (sizeMb / originalSizeMb) * 100);
                    outputSizeSlider.value = percent.toFixed(1);
                    updateOutputSizeDisplay();
                }
            });
        });

        function updateOutputSizeDisplay() {
            if (!originalSizeMb || !Number.isFinite(originalSizeMb)) {
                outputSizeValue.textContent = '--';
                outputSizeDetails.textContent = '';
                return;
            }

            const percent = parseFloat(outputSizeSlider.value);
            const targetSizeMb = (originalSizeMb * percent) / 100;
            
            // Display the target size
            const displayValue = targetSizeMb >= 10 ? targetSizeMb.toFixed(0) : targetSizeMb.toFixed(1);
            outputSizeValue.textContent = `${displayValue} MB (${percent.toFixed(0)}% of original)`;

            if (!sourceDuration || !sourceVideoWidth || !sourceVideoHeight) {
                outputSizeDetails.textContent = 'Waiting for video metadata...';
                return;
            }

            // Calculate target bitrate
            const targetBitsTotal = (targetSizeMb * 1024 * 1024 * 8 * 0.9); // 90% efficiency
            const targetBitrateKbps = targetBitsTotal / sourceDuration / 1000;
            const videoBitrateKbps = Math.max(100, targetBitrateKbps - 128); // reserve 128k for audio

            // Calculate recommended resolution scaling
            const recommendedScale = calculateOptimalResolution(targetSizeMb, sourceDuration, sourceVideoWidth, sourceVideoHeight);
            
            const targetW = Math.floor((sourceVideoWidth * recommendedScale / 100) / 2) * 2;
            const targetH = Math.floor((sourceVideoHeight * recommendedScale / 100) / 2) * 2;
            
            let details = `Target bitrate: ~${Math.round(targetBitrateKbps)} kbps`;
            
            if (recommendedScale < 100) {
                details += ` · Resolution: ${targetW}×${targetH} (${recommendedScale}%)`;
            } else {
                details += ` · Resolution: ${sourceVideoWidth}×${sourceVideoHeight} (original)`;
            }
            
            outputSizeDetails.textContent = details;
        }
        
        function calculateOptimalResolution(targetSizeMb, durationSec, width, height) {
            // Calculate target bitrate (90% for overhead)
            const targetBitsTotal = (targetSizeMb * 1024 * 1024 * 8 * 0.9);
            const targetBitrateKbps = targetBitsTotal / durationSec / 1000;
            const videoBitrateKbps = targetBitrateKbps - 128; // subtract audio

            // Calculate pixels
            const pixels = width * height;

            // Target bits per pixel per second (empirical quality threshold)
            // For H.264: 0.1 bpp is decent, 0.07 is acceptable, below 0.05 looks bad
            const bitsPerPixel = (videoBitrateKbps * 1000) / pixels / 30; // assume 30fps

            // If we have enough bitrate, keep full resolution
            if (bitsPerPixel >= 0.1) {
                return 100;
            }

            // Calculate scale factor to reach target bpp of 0.1
            const targetBpp = 0.1;
            const scaleFactor = Math.sqrt(bitsPerPixel / targetBpp);
            let scalePercent = Math.min(100, Math.round(scaleFactor * 100));

            // Ensure minimum 480p height (SD quality)
            const minHeight = 480;
            const heightScalePercent = Math.round((minHeight / height) * 100);
            scalePercent = Math.max(scalePercent, heightScalePercent);

            // Final clamp to ensure we don't go below minimum scale
            scalePercent = Math.max(25, scalePercent);

            return scalePercent;
        }

        function updateCodecHelper() {
            const details = codecDetails[codecSelect.value];
            if (details) {
                codecHelper.textContent = details.helper;
            } else {
                codecHelper.textContent = '';
            }
        }

        uploadBtn.addEventListener('click', async (e) => {
            // Prevent bubbling to the upload area which would reopen the file picker
            e.stopPropagation();
            if (!selectedFile) return;

            uploadBtn.disabled = true;
            uploadBtn.textContent = 'Uploading...';
            progressDiv.style.display = 'block';
            progressFill.style.width = '10%';

            const formData = new FormData();
            formData.append('file', selectedFile);
            formData.append('mode', 'simple'); // Always use simple mode with target size
            formData.append('codec', codecSelect.value);
            
            // Calculate target size from slider
            const percent = parseFloat(outputSizeSlider.value);
            const targetSizeMb = (originalSizeMb * percent) / 100;
            formData.append('targetSizeMb', targetSizeMb.toFixed(2));
            
            // Calculate optimal resolution scaling
            const calculatedScalePercent = calculateOptimalResolution(
                targetSizeMb,
                sourceDuration,
                sourceVideoWidth,
                sourceVideoHeight
            );
            formData.append('scalePercent', calculatedScalePercent);
            
            if (sourceDuration && isFinite(sourceDuration)) {
                formData.append('sourceDuration', sourceDuration.toFixed(3));
            }
            if (Number.isFinite(sourceVideoWidth) && sourceVideoWidth > 0) {
                formData.append('sourceWidth', sourceVideoWidth);
            }
            if (Number.isFinite(sourceVideoHeight) && sourceVideoHeight > 0) {
                formData.append('sourceHeight', sourceVideoHeight);
            }
            formData.append('originalSizeBytes', selectedFile.size);

            // Log compression parameters for debugging
            console.log('Compression request:', {
                mode: 'simple',
                codec: codecSelect.value,
                targetSizeMb: targetSizeMb.toFixed(2),
                targetPercent: percent,
                sourceDuration: sourceDuration,
                originalSizeMb: originalSizeMb.toFixed(2),
                scalePercent: calculatedScalePercent
            });

            try {
                const response = await fetch('/api/compress', {
                    method: 'POST',
                    body: formData
                });

                if (!response.ok) {
                    let errorMsg = `Server error (${response.status})`;
                    try {
                        const errorData = await response.json();
                        errorMsg = errorData.error || errorData.detail || errorMsg;
                    } catch (e) {
                        errorMsg = await response.text() || errorMsg;
                    }
                    throw new Error(errorMsg);
                }

                const result = await response.json();
                jobId = result.jobId;

                progressFill.style.width = '100%';
                progressFill.classList.add('compressing');
                showStatus('Video uploaded successfully. Compressing...', 'processing');

                // Start checking status
                statusCheckInterval = setInterval(checkStatus, 2000);

            } catch (error) {
                console.error('Upload failed:', error);
                let errorMessage = error.message;
                
                // Provide more helpful error messages
                if (errorMessage.includes('NetworkError') || errorMessage.includes('Failed to fetch')) {
                    errorMessage = 'Network error: File may be too large or server is unreachable. Please try a smaller file or check your connection.';
                } else if (errorMessage.includes('413')) {
                    errorMessage = 'File is too large. The server cannot accept files this big.';
                }
                
                showStatus('Upload failed: ' + errorMessage, 'error');
                uploadBtn.disabled = false;
                uploadBtn.textContent = 'Upload & Compress Video';
                progressDiv.style.display = 'none';
            }
        });

        async function checkStatus() {
            try {
                const response = await fetch(`/api/status/${jobId}`);
                if (response.ok) {
                    const result = await response.json();
                    if (result.status === 'processing') {
                        // Show real progress from FFmpeg
                        const progressPercent = Math.max(10, Math.min(95, result.progress || 0));
                        progressFill.style.width = `${progressPercent}%`;
                        showStatus(`Compressing video... ${progressPercent.toFixed(1)}%`, 'processing');
                    } else if (result.status === 'completed') {
                        clearInterval(statusCheckInterval);
                        progressFill.style.width = '100%';
                        progressFill.classList.remove('compressing');
                        downloadFileName = result.outputFilename || `compressed_${selectedFile.name}`;
                        downloadMimeType = result.outputMimeType || 'video/mp4';
                        showStatus('Compression complete! Click download button.', 'success');
                        downloadBtn.style.display = 'block';
                        progressDiv.style.display = 'none';
                    } else if (result.status === 'failed') {
                        clearInterval(statusCheckInterval);
                        progressFill.classList.remove('compressing');
                        showStatus('Compression failed: ' + (result.message || 'Unknown error'), 'error');
                        uploadBtn.disabled = false;
                        uploadBtn.textContent = 'Upload & Compress Video';
                        progressDiv.style.display = 'none';
                    }
                } else {
                    clearInterval(statusCheckInterval);
                    progressFill.classList.remove('compressing');
                    const errorData = await response.json().catch(() => ({}));
                    showStatus('Compression failed: ' + (errorData.error || 'Unknown error'), 'error');
                    uploadBtn.disabled = false;
                    uploadBtn.textContent = 'Upload & Compress Video';
                    progressDiv.style.display = 'none';
                }
            } catch (error) {
                console.error('Status check failed:', error);
                clearInterval(statusCheckInterval);
                progressFill.classList.remove('compressing');
                showStatus('Failed to check status: ' + error.message, 'error');
                uploadBtn.disabled = false;
                uploadBtn.textContent = 'Upload & Compress Video';
                progressDiv.style.display = 'none';
            }
        }

        downloadBtn.addEventListener('click', () => {
            if (jobId) {
                // Create a temporary link to download the file
                const link = document.createElement('a');
                link.href = `/api/download/${jobId}`;
                link.download = downloadFileName || `compressed_${selectedFile?.name ?? jobId}`;
                if (downloadMimeType) {
                    link.type = downloadMimeType;
                }
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);

                // Reset the interface
                resetInterface();
            }
        });

        function showStatus(message, type) {
            statusDiv.textContent = message;
            statusDiv.className = `status-${type}`;
            statusDiv.style.display = 'block';
        }

        function resetInterface() {
            if (statusCheckInterval) {
                clearInterval(statusCheckInterval);
                statusCheckInterval = null;
            }
            selectedFile = null;
            jobId = null;
            fileInfo.textContent = '';
            statusDiv.style.display = 'none';
            downloadBtn.style.display = 'none';
            progressDiv.style.display = 'none';
            progressFill.style.width = '0%';
            progressFill.classList.remove('compressing');
            uploadBtn.disabled = true;
            uploadBtn.textContent = 'Upload & Compress Video';
            fileInput.value = '';
            controlsDiv.style.display = 'none';
            metadataDiv.style.display = 'none';
            downloadFileName = null;
            downloadMimeType = null;
            outputSizeSlider.disabled = true;
            outputSizeSlider.value = 100;
            outputSizeValue.textContent = '--';
            outputSizeDetails.textContent = '';
            codecSelect.value = 'h264';
            updateCodecHelper();
            sourceVideoWidth = null;
            sourceVideoHeight = null;
            sourceDuration = null;
            originalSizeMb = null;
            if (objectUrl) URL.revokeObjectURL(objectUrl);
            objectUrl = null;
        }
    </script>
</body>
</html>
